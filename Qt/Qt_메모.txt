Qt 메모

- 빌드 관련
qmake와 CMake 방식 두개가 가장 추천되는데 간단한 것은 qmake다.
내가 배운 강의에서는 CMake가 빌드 표준으로 자리잡고 있기 때문에 CMake를 추천한다.
CMake가 다 좋은데 약간의 귀찮은 것은 파일을 추가하면 해당 파일이 추가되었는지 CMakeLists.txt에 알려줘야 한다는 것이다.
예를 들어 dog.h, dog.cpp가 추가되었다면 CMakeLists.txt 내에 있는 add_executable 항목에 dog.h, dog.cpp를 추가해주고 세이브해줘야 정상적으로 QtCreator 파일 탭에 보인다.
CMake가 qmake보다 좋은 점은 3rd party 라이브러리를 추가하기가 용이하다는 것이다. 엥간한 오픈 소스 라이브러리들은 CMake로 라이브러리를 추가하는 메뉴얼을 제공하지만 qmake에 관련된 메뉴얼은 거의 없다.

- 주석 관련

/*! 라는 Doxygen이라는 외부 주석 관리 프로그램과 연관된 특수 주석이 Qt에는 존재한다.
Qt Creator에서 /*!를 하고 엔터를 치는 순간 함수 이름, 함수 인자, 반환값 등에 관련해서 손쉽게 주석을 달 수 있도록 구조를 만들어 준다.

- qFatal()
이 녀석이 수행되면 앱을 강제 종료함. 더이상 앱을 수행하기 어렵다고 판단될 때 사용함.
ex) qFatal("App have to shut down!");

- QOjbect
모든 Qt 클래스는 기본적으로 QObject를 상속하고 있다. 그리고 QObject를 상속해서 사용할 때 반드시 클래스 내부에 Q_OBJECT 매크로를 선언해야 QObject의 기능을 정상적으로 이용할 수 있다. QObject를 상속한 클래스들은 Signals and Slots이라는 시스템 사용이 가능하다. (QOjbect끼리 메시지 주고 받는 것이 용이해진다.)
QObject는 복사가 안된다. 동적 할당을 하거나 복사를 하지 않고 사용할 수 밖에 없다.
예를 들어 QObject GetObject() { QObject object; return object; } 이러한 함수 작성이 불가능하다는 것이다.
이렇게 QObject와 같이 자신이 만든 다른 클래스에서도 복사가 되는 것을 막으려면 Q_DISABLE_COPY(클래스 이름)을 Q_OBJECT 매크로를 선언하듯 해주면 된다. (자매품으로 Q_DISABLE_MOVE, Q_DISABLE_COPY_MOVE도 있다...)
QOjbect 상속하는 모든 자식 클래스들은 스마트 포인터를 사용한 것과 같이 자동 메모리 해제 기능을 이용할 수가 있게 된다.
QObject는 템플릿 클래스와 같이 사용할 수 없다.
밑의 예시를 보자.

class Cat : public QObject
{
	Q_OBJECT
public:
	Cat(QObject *parent = nullptr) : QObject(parent) {};
	~Cat() {};
};

class Dog : public QObject
{
	Q_OBJECT
public:
	Dog(QObject *parent = nullptr) : QObject(parent) {};
	~Dog() {};
};

int main(int argc, char *argv[])
{
	QCoreApplication app(argc, argv);
	Cat *myCat = new Cat(&app);
	Dog *myDog = new Dog(&app);
	
	Cat *yourCat = new Cat(&app);
	Dog *yourDog = new Dog(&yourCat);
	delete yourCat;
	
	return app.exec();
}

이러한 상황에서 app 실행이 종료가 되는 시점에 이에 붙어 있던 QObject들을 모두 하나씩 보면서 동적 할당을 해제해주기 때문에 따로 delete를 해줄 필요가 없다.
위 예제에서는 지금 app이 myCat과 myDog의 parent로 위치하기 때문에 따로 할당 해제에 신경을 쓸 필요가 없다.
yourCat을 delete를 해주면 이 녀석에 딸려있던 yourDog까지 같이 할당 해제가 된다.
주의할 점은 Q_OBJECT 매크로가 주석에 있던 실제 코드로 작성이 되었던 해당 파일에 QObject가 사용된 것으로 Qt Creator가 인식을 하고 그 파일에 대한 moc 파일을 생성하려고 시도를 하니 이를 유념하면서 코드를 작성해야 한다.
예를 들어 main.cpp에 Q_OBJECT 글자가 적히면 main에 대한 moc는 생성이 안되기에 컴파일이 안된다.

- Signals and Slots
단순히 말하면 C++의 CallBack 함수이다. MFC나 Win32에서 메시징 시스템이라고 생각하면 쉽다.
순수 C++로 구현한 예시들은 밑 링크에 있다.
https://stackoverflow.com/questions/14189440/c-callback-using-class-member
https://stackoverflow.com/questions/2298242/callback-functions-in-c
하지만 사용하기 불편하고 환경에 따라 변형해서 사용해야 한다.
이를 Qt가 쓰레드 안정적이고 범용적이고 사용하기 쉬운 인터페이스로 만들어 놓은 것이다.
밑은 그 예시다.

class Cat : public QObject
{
    Q_OBJECT
public:
    Cat(QObject *parent = nullptr) : QObject(parent) {};
    ~Cat() {};

signals:
    void Calling(QString strName);

public slots:
    void Run() { qInfo() << sender() << "is Bark! so Run!"; }
};

class Dog : public QObject
{
    Q_OBJECT
public:
    Dog(QObject *parent = nullptr) : QObject(parent) {};
    ~Dog() {};

signals:
    void Bark();

public slots:
    void Hearing(QString strName)
    {
        qInfo() << "Dog hears Cat is calling" << strName;
    }
};

int main(int argc, char *argv[])
{
	QCoreApplication app(argc, argv);
	
    Dog myDog(&app);
    Cat myCat(&app);
	
    QObject::connect(&myDog, &Dog::Bark, &myCat, &Cat::Run);
    QObject::connect(&myCat, &Cat::Calling, &myDog, &Dog::Hearing);
	
	emit myDog.Bark();
	
	QObject::disconnect(&myDog, &Dog::Bark, &myCat, &Cat::Run);
	
	emit myCat.Calling("doggy");
	
	return app.exec();
}

위의 상황에서 myDog의 Bark() 함수를 호출하면 자동적으로 myCat의 Run()함수도 호출된다. 즉 signal을 보내면 slot이 반응하는 것이다.
singal의 함수 인자가 QString이라면 이에 반응하는 slot의 함수 인자도 QString으로 동일해야 한다. 즉 연결할 signal과 slot의 함수 인자 형식을 맞춰줘야 한다.
connect() 함수를 이용해서 singal과 slot을 연결한다.
connect() 함수는 많은 옵션이 있는데 default 옵션은 AutoConnection이다. 
이러한 경우 QObject::connect(&myDog, &Dog::Bark, &myCat, &Cat::Run); QObject::connect(&myDog, &Dog::Bark, &myCat, &Cat::Run); 두 번 쓰여지면 Bark() 한번에 Run()이 두번 실행되게 된다. 이를 해결하려면 QObject::connect(&myDog, &Dog::Bark, &myCat, &Cat::Run, Qt::UniqueConnection); 이렇게 connection 옵션을 마지막에 넣어주면 된다. (다른 옵션도 많으니 Qt document에서 찾아보자.)
signal을 보낼 때는 꼭 emit myDog.Bark();와 같이 emit을 붙이고 signal 함수를 호출해야 한다.
signals에 정의된 함수들은 선언만 해야하며 slots에 있는 함수는 선언과 구현을 모두 해야한다.
slots에 구현된 함수는 일반 함수처럼 사용할 수 있다. 
slots에 구현된 함수 내부에서는 sender()라는 함수를 사용할 수 있는데 signal을 보낸 QObject의 주소를 반환한다.
하나의 signal에 여러개의 slot이 연결될 수 있다.
연결을 끊을 때는 disconnect() 함수를 이용하면 된다.

- Q_PROPERY
C#에서 잘 쓰이는 프로퍼티 바인딩을 Qt에서 C++에서도 사용할 수 있게 해놓은 것이다.
기본적인 형태은 다음과 같다.
Q_PROPERY(type name READ name WRITE setname NOTIFY nameChanged)
처음부터 각각 type -> 바인딩할 변수 타입, name -> 바인딩할 변수 이름 / READ / name -> getter 함수 이름 / WRITE / setname -> setter 함수 이름 / NOTIFY / nameChanged -> 바인딩 변수에 변화가 생길 때 트리거 되는 함수 이름
밑은 예시이다.

class Dog : public QObject
{
    Q_OBJECT
    Q_PROPERTY(int Age READ GetAge WRITE SetAge NOTIFY AgeChanged)
    Q_PROPERTY(QString Name READ GetName WRITE SetName NOTIFY NameChanged)

    int m_nAge;
    QString m_strName;

public:
    Dog(QObject *parent = nullptr) : QObject(parent)
    {
        connect(this, &Dog::NameChanged, this, &Dog::PrintWhenNameChanged);
        connect(this, &Dog::AgeChanged, this, &Dog::PrintWhenAgeChanged);
    };
    ~Dog() {};

    const QString& GetName() const { return m_strName; }
    void SetName(const QString &str) { m_strName = str; emit NameChanged(); }

    const int& GetAge() const { return m_nAge; }
    void SetAge(const int &num) { m_nAge = num; emit AgeChanged(); }

public slots:
    void PrintWhenNameChanged() { qInfo() << "Name is Changed!"; }
    void PrintWhenAgeChanged() { qInfo() << "Age is Changed!"; }

signals:
    void NameChanged();
    void AgeChanged();
};

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);

    Dog *myDog = new Dog(&app);
    QObject *myObject = myDog;

    myDog->SetName("MeatBoy");
    qInfo() << myDog->GetName();

    myObject->setProperty("Name", "BandageGirl");
    qInfo() << myObject->property("Name").toString();

    myDog->SetAge(9);
    qInfo() << myDog->GetAge();

    myObject->setProperty("Age", "11");
    qInfo() << myObject->property("Age").toInt();

    return app.exec();
}

위 코드에서 Q_PROPERTY(QString Name READ GetName WRITE SetName NOTIFY NameChanged) 이렇게 선언한 것을 볼 수가 있다.
주의할 점은 NOTIFY 부분인데 NOTIFY NameChanged를 했다고 해서 SetName 함수가 호출될 때 emit NameChanged() 해주는 것이 아니다. (단, QML에서는 emit을 자동으로 해준다고 한다.)
따라서 C++에서 사용할 때는 SetName에 emit NameChanged()를 넣어줘야 한다.
property 함수가 호출되면 알맞은 getter가 setProperty 함수가 호출되면 알맞은 setter가 실행된다.
C++에서의 Q_PROPERTY 사용 의미는 주로 여러 개의 QObject를 일괄 처리할 때인데 잘보면 Age는 int인데 setProperty("Age", "11")로 스트링 형태로 넣어줘도 잘 처리되는 것을 볼 수 있다.
Q_PROPERY와 signals and slots 기술은 Qt의 moc 파일 생성을 통해 작동하기 때문에 컴파일 도중 변경된 moc 파일을 적용하겠다고 물어보면 yes to all을 누르는 것이 좋다.

- Qt에서의 예외처리
C++에서와 동일한데 qWarning()을 같이 사용하는 것이 권장된다.
밑은 코드 예시이다.

class CustomException : public std::exception
{
private:
    const char* m_strMessage;
public:
    CustomException(const char* strMsg)
    {
        m_strMessage = strMsg;
    }
    const char* what() const throw()
    {
        return m_strMessage;
    }
};

bool DivideSomething(int nNumer, int nDenom, int& nRet)
{
    try {
        if(!nDenom)
            throw CustomException("Can't divide number by zero!");
        nRet = nNumer/nDenom;
    }
    catch (CustomException& e) {
        qWarning() << e.what();
        return false;
    }
    return true;
}

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);

    int nRet = 0;
    DivideSomething(5, 0, nRet);
    return app.exec();
}

위 코드 처럼 예외처리 클래스를 따로 정의해서 해도 되고 그냥 throw QString("Error!");처럼 문자열 자체를 던져버려도 된다.

- C++ vs Qt

1. std::cout <-> qInfo() [또는 qDebug(), qCritical(), qWarning() 등등...]
차이라면 버퍼를 비워주는 flush를 qInfo()에서는 인위적으로 해줄 필요가 없다. cout에서 endl을 많이 쓰면 안좋다는 말이 flush가 endl에서 같이 수행되기 때문인데 qInfo()에서는 endl을 사용할 필요가 없다.

2. static_cast, dynamic_cast... 등등 표준 형변환 vs qobject_cast
일단 qobject_cast는 QObject를 상속한 클래스에서만 사용이 가능하기에 나머지 상황에서는 표준 형변환을 써야한다.
QObject를 상속한 클래스에서는 qobject_cast를 사용하는 것이 안전하다.

3. int, long, long long... vs qint8, qint16, qint32...
OS별로 코드를 따로 짜고 싶지 않다면 qint형을 사용하는 것이 편하다.

4. QString vs std::string
Qt에서는 QString을 사용하는 것이 좋다.
std::string에서는 지원하지 않는 split, arg, asprintf 등의 편의 기능을 QString은 가지고 있다. 또한 QString은 wchar과 char를 유동적으로 지원한다.

5. delete vs qDeleteAll
크기가 큰 배열, 구조체 묶음 등을 동적 할당 해제하는 경우에는 qDeleteAll이 편하다.